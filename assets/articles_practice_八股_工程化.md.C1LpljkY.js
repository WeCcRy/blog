import{_ as i,c as a,o as n,ae as t}from"./chunks/framework.z0sZ1NT9.js";const l="/blog/assets/ws%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%9B%B4%E6%96%B0.D5mny4WR.png",g=JSON.parse('{"title":"工程化","description":"","frontmatter":{},"headers":[],"relativePath":"articles/practice/八股/工程化.md","filePath":"articles/practice/八股/工程化.md"}'),h={name:"articles/practice/八股/工程化.md"};function p(k,s,e,r,d,E){return n(),a("div",null,s[0]||(s[0]=[t('<h1 id="工程化" tabindex="-1">工程化 <a class="header-anchor" href="#工程化" aria-label="Permalink to &quot;工程化&quot;">​</a></h1><h2 id="浏览器是如何渲染页面的" tabindex="-1">浏览器是如何渲染页面的 <a class="header-anchor" href="#浏览器是如何渲染页面的" aria-label="Permalink to &quot;浏览器是如何渲染页面的&quot;">​</a></h2><ol><li>浏览器从后端获取到html文件</li><li>浏览器将html文本拆成token，流程如下，逐字符读取(scanner)： <ol><li>读到 &lt;：判断 “开始标签的起始”，继续读后面的字符；</li><li>读到 p：判断是标签名（<code>&lt;p&gt;</code>），生成一个 “开始标签 Token”，类型标记为StartTag:p；</li><li>读到空格：判断 “标签名结束，接下来是属性”，继续读；</li><li>读到 c-l-a-s-s：识别为属性名 “class”，再读到 = 和 &quot;text&quot;，生成一个 “属性 Token”，关联到前面的StartTag:p；</li><li>读到 &gt;：判断 “开始标签结束”，完成StartTag:p的生成；</li><li>读到 H-e-l-l-o W-o-r-l-d：没有 &lt; 开头，判断是文本内容，生成 “文本 Token”，内容为 “Hello World”；</li><li>读到 &lt;：再次进入标签识别，继续读 /p&gt;，生成 “结束标签 Token”，类型标记为EndTag:p。</li><li>最终这一段文本会拆成 3 个核心 Token：[StartTag:p(属性:class=&quot;text&quot;), Text:Hello World, EndTag:p]</li></ol></li><li>通过token生成dom节点：一边读取token，一边通过栈来存储，因为标签都需要闭合，所以可以形成一个个dom节点</li><li>通过嵌套关系构成dom树</li><li>当html解析中遇到<code>&lt;link&gt;</code>链接的时候，会请求链接对应的css文件，如果是行内的<code>&lt;style&gt;</code>则直接解析，后面定义的css，如果前者更高的优先级就会被后者覆盖</li><li>通过DOM和CSSOM构建RenderTree，因为css的条数众多，因此在匹配css和对应节点的时候，使用的是从右到左的匹配方式，可以筛选掉大量的不匹配节点</li><li>下一步进行布局计算（回流/重排 reflow），需要根据节点的样式信息和层级关系，计算元素在屏幕上的位置、宽高、间距等 <ol><li>一般以html根元素的大小为基准，根元素的大小受视口大小影响，定义的root样式作用在html根元素上，body包含了所有的可见元素</li><li>基于盒子模型确定元素的大小</li><li>根据布局模式确定元素的排列（正常流，浮动，定位，flex，grid）</li><li>递归计算，从根节点开始，先计算父元素的布局信息，再将必要的约束传递给子元素，子元素基于这些约束计算自己的布局，同时可能将结果反馈给父元素，形成 “父→子→父” 的递归循环。</li></ol></li><li>下一步进行重绘，即填充像素，浏览器会分成多个绘制层计算</li><li>将多个绘制层合并成多个合并层</li><li>引入script <ol><li>引入script时候，会打断原来DOM的解析过程 <ol><li>引入async script。导致的结果就是异步下载script，拿到script后再执行，实质还是会阻塞html的解析，只不过大多数情况下，在获取到script之后，dom已经加载完毕了</li><li>只有外部脚本才可以使用async</li><li>defer script就是异步加载，但是等到dom加载完毕后再执行script</li></ol></li><li>默认script写在不同地方的影响 <ol><li>如果写在header中，会请求并加载script，导致无法获取script中的dom对象，可能部分功能失效</li><li>如果写在body的顶部，其结果与header中一致</li><li>如果写在body中部，则可以获取到script标签上方的dom元素</li><li>如果写在body底部和body后，则可以获取到全量的dom元素</li></ol></li></ol></li></ol><p>补充：</p><ol><li>css编写方式的影响：使用style编写的时候，会自动执行解析，而使用link的时候，会先请求，待请求完毕后再解析</li></ol><h2 id="白屏" tabindex="-1">白屏 <a class="header-anchor" href="#白屏" aria-label="Permalink to &quot;白屏&quot;">​</a></h2><p>可能是资源过大，当资源未完全加载完成的时候，浏览器不会渲染DOM</p><p>可能是浏览器引入的script脚本中，存在死循环导致阻塞</p><h2 id="当我点击页面上一个button两次发生了什么" tabindex="-1">当我点击页面上一个button两次发生了什么 <a class="header-anchor" href="#当我点击页面上一个button两次发生了什么" aria-label="Permalink to &quot;当我点击页面上一个button两次发生了什么&quot;">​</a></h2><p>所有的 addEventListener 触发的回调，均会按序添加到一个临时的事件处理队列，默认的addEventListener 监听的是冒泡阶段。等到一个<code>捕获-&gt;目标-&gt;冒泡</code>流程完成后，将临时队列中的内容添加到宏任务队列中等待事件循环机制执行</p><h3 id="事件捕获" tabindex="-1">事件捕获 <a class="header-anchor" href="#事件捕获" aria-label="Permalink to &quot;事件捕获&quot;">​</a></h3><p>浏览器从 最顶层的文档根节点（document） 开始，向下遍历 DOM 树，直到找到被点击的 button 元素。</p><p>如果经过的节点在addEventLister中配置了 {capture:true} ，则会把 click 对应的回调函数添加到临时任务队列</p><h3 id="事件目标" tabindex="-1">事件目标 <a class="header-anchor" href="#事件目标" aria-label="Permalink to &quot;事件目标&quot;">​</a></h3><p>将 button 的点击事件添加到临时任务队列</p><h3 id="事件冒泡" tabindex="-1">事件冒泡 <a class="header-anchor" href="#事件冒泡" aria-label="Permalink to &quot;事件冒泡&quot;">​</a></h3><p>事件从目标元素 button 开始，向上回溯 DOM 树，回到文档根节点。同时将经过元素的 click 回调事件加入临时任务队列</p><p>以上是单次点击的流程，如果点击两次则会触发两次，同时浏览器会监听两次单击的时间间隔，如果间隔少于一定时间，则会触发dbclick事件。dbclick 事件同样会走<code>捕获-&gt;目标-&gt;冒泡</code>的流程</p><p>最后将临时任务队列中的回调添加到全局的宏任务队列等待事件循环机制执行</p><p>PS：原生的dbclick一定先触发两次click事件，如果需要取消click事件，需要在click 回调中监听两次操作的间隔。</p><p>Finally:[第一次点击的捕获回调 → 第一次点击的目标回调 → 第一次点击的冒泡回调 → 第二次点击的捕获回调 → 第二次点击的目标回调 → 第二次点击的冒泡回调 → dblclick的捕获回调 → dblclick的目标回调 → dblclick的冒泡回调]</p><p><strong>addEventListener(type, listener, options)</strong></p><ul><li><p>type: 事件名称，大小写敏感</p></li><li><p>listener: 回调事件</p></li><li><p>options: 可选配置参数</p><ul><li><p>capture: boolean。表示事件是在捕获阶段事发还是冒泡阶段触发，默认为false，即冒泡阶段触发</p></li><li><p>once:boolean。为true时，当执行一次完毕后就会销毁监听器</p></li></ul></li></ul><p>对目标元素的 capture 配置无论是 true 还是 false ，都会在目标阶段执行，但 capture 为 true 的事件会在 capture 为 false 的事件前执行(可以对一个目标元素的一个事件配置两个回调函数，通过 capture 来区分出先后)。对于 capture 配置一样的则是先绑定的先执行。</p><h2 id="vite是如何实现冷启动和热更新的" tabindex="-1">Vite是如何实现冷启动和热更新的 <a class="header-anchor" href="#vite是如何实现冷启动和热更新的" aria-label="Permalink to &quot;Vite是如何实现冷启动和热更新的&quot;">​</a></h2><p>是基于 ESM 模式实现的，Vite需要在入口文件的<code>&lt;script&gt;</code>中配置<code>type=&quot;module&quot;</code>，使得浏览器可以执行<code>&lt;script&gt;</code>中的<code>import</code>。添加了<code>type=&quot;module&quot;</code> 会使得 <code>script</code> 有 <code>defer</code> 的效果</p><p>当然，原生的 JS 是不支持import xx from &#39;xx&#39;这种模块路径的 ，因此 Vite 启动了一个开发服务器，拦截浏览器的模块请求，并动态解析和返回模块内容（也就是 localhost:xx ），比如说解析包地址(类似将&#39;vue&#39;解析到 node_modules 中)，通过 ESM 的方式加载模块，Vite 会将非 JS 文件（如 .vue、.ts）通过编译工具转换为浏览器可识别的 JS 模块。</p><p>一般来说，本地的虚拟服务器指向的是index.html这个入口文件，然后会逐步解析（index.html中引入的script,该后续引入的script和import）。通过ESM的方式导入到浏览器中，如果导入的文件发生了更新，Vite会捕获到更新，并同步到浏览器中。</p><p>Vite可以实现热更新是因为 Vite 启动的服务器与浏览器是建立了Websocket的连接，当浏览器第一次打开本地服务器地址的时候，会通过http建立Websocket的连接，后续的信息交换都是通过websocket实现的</p><p><img src="'+l+`" alt=""></p><p>从图片中可以看到，当我修改了Vite中的vue文件时，会通过 websocket 实现信息的传递，当浏览器接收到信息后，会获得组件的地址，以此重新加载组件。当开启了热更新后，每次更新组件之后都会通知浏览器重新获取更新的组件。如果关闭了热更新的话(hmr:false)，Vite 不会再在组件更新的时候通知浏览器，需要手动刷新</p><h2 id="git和svn-的区别" tabindex="-1">git和svn 的区别 <a class="header-anchor" href="#git和svn-的区别" aria-label="Permalink to &quot;git和svn 的区别&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>问题</strong></th><th><strong>Git</strong></th><th><strong>SVN</strong></th></tr></thead><tbody><tr><td><strong>模型类型</strong></td><td>分布式（Distributed）</td><td>集中式（Centralized）</td></tr><tr><td><strong>核心差异</strong></td><td>- 每个开发者本地有完整仓库副本 - 数据分散存储，支持离线操作</td><td>- 所有代码存储在中央服务器 - 必须联网才能提交代码</td></tr><tr><td><strong>分支实现</strong></td><td>- 轻量级分支（创建 / 切换耗时毫秒级） - 基于指针（commit 哈希），不复制文件</td><td>- 重量级分支（基于文件系统复制） - 耗存储、操作慢（尤其大项目）</td></tr><tr><td><strong>合并能力</strong></td><td>- 支持三方合并（自动识别共同祖先） - 冲突解决灵活（可视化工具如 VS Code）</td><td>- 依赖路径匹配，跨分支合并易出错 - 复杂场景需手动处理冲突</td></tr></tbody></table><h2 id="git常用命令" tabindex="-1">git常用命令 <a class="header-anchor" href="#git常用命令" aria-label="Permalink to &quot;git常用命令&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">git init                     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新建 git 代码库</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">git add                      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加指定文件到暂存区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">git rm                       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 删除工作区文件，并且将这次删除放入暂存区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">git commit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">m [message]      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 提交暂存区到仓库区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">git branch                   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 列出所有分支</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">git checkout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b [branch]     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新建一个分支，并切换到该分支</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">git status                   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 显示有变更文件的状态</span></span></code></pre></div><h2 id="git-pull-和-git-fetch-的区别" tabindex="-1">git pull 和 git fetch 的区别 <a class="header-anchor" href="#git-pull-和-git-fetch-的区别" aria-label="Permalink to &quot;git pull 和 git fetch 的区别&quot;">​</a></h2><ul><li>git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。</li><li>git pull 会将远程仓库的变化下载下来，并和当前分支合并。</li></ul><h2 id="git-rebase-和-git-merge-的区别" tabindex="-1">git rebase 和 git merge 的区别 <a class="header-anchor" href="#git-rebase-和-git-merge-的区别" aria-label="Permalink to &quot;git rebase 和 git merge 的区别&quot;">​</a></h2><p>git merge 和 git rebase 都是用于分支合并，关键在 <strong>commit 记录的处理上不同</strong>：</p><ul><li>git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。</li><li>git rebase ,当前所在分支为源分支，rebase xx中的xx为目标分支，会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取源分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了<strong>线性的记录</strong>了。</li></ul><h2 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h2><h3 id="创造模式" tabindex="-1">创造模式 <a class="header-anchor" href="#创造模式" aria-label="Permalink to &quot;创造模式&quot;">​</a></h3><h4 id="单例模式" tabindex="-1">单例模式 <a class="header-anchor" href="#单例模式" aria-label="Permalink to &quot;单例模式&quot;">​</a></h4><p>确保一个类只有一个实例，并提供一个全局访问点来访问该实例。</p><h4 id="工厂模式" tabindex="-1">工厂模式 <a class="header-anchor" href="#工厂模式" aria-label="Permalink to &quot;工厂模式&quot;">​</a></h4><h5 id="简单工厂" tabindex="-1">简单工厂 <a class="header-anchor" href="#简单工厂" aria-label="Permalink to &quot;简单工厂&quot;">​</a></h5><p>通过一个工厂生产所有产品</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 产品接口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Base product&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 具体产品</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteProductA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Product A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteProductB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Product B&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 简单工厂</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Factory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  createProduct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteProductA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;B&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteProductB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Invalid product type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用工厂</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> factory</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Factory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> productA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> factory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createProduct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(productA.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: &quot;Product A&quot;</span></span></code></pre></div><h5 id="工厂方法" tabindex="-1">工厂方法 <a class="header-anchor" href="#工厂方法" aria-label="Permalink to &quot;工厂方法&quot;">​</a></h5><p>工厂提供一个接口，子类实现接口</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 工厂基类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Creator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  abstract</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> factoryMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 抽象产品，具体产品由子类实现</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  someOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> product</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">factoryMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Operation with \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">product</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">operation</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 具体工厂</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteCreatorA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Creator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  factoryMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteProductA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteCreatorB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Creator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  factoryMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteProductB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用工厂</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> creatorA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteCreatorA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(creatorA.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">someOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: &quot;Operation with Product A&quot;</span></span></code></pre></div><h3 id="结构型模式" tabindex="-1">结构型模式 <a class="header-anchor" href="#结构型模式" aria-label="Permalink to &quot;结构型模式&quot;">​</a></h3><h4 id="适配器模式" tabindex="-1">适配器模式 <a class="header-anchor" href="#适配器模式" aria-label="Permalink to &quot;适配器模式&quot;">​</a></h4><p>当两个接口不兼容（如旧接口与新系统不匹配），通过一个 “适配器” 中间层，将一个接口转换为另一个接口，使原本无法一起工作的组件可以协同</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 目标接口（新系统需要的接口）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ImagePrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  printImage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">image</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 被适配者（旧接口，不兼容新系统）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OldPrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  printText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">text</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`OldPrinter 打印文本：\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">text</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 适配器（组合被适配者，转换接口）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PrinterAdapter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ImagePrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  private</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> oldPrinter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OldPrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 持有被适配者实例</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldPrinter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OldPrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.oldPrinter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldPrinter;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 将 printImage 转换为旧接口的 printText</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  printImage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">image</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 模拟图片转文本逻辑（实际可能更复杂）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> text</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;图片内容&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">image;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.oldPrinter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldPrinter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OldPrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> adapter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PrinterAdapter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldPrinter);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">adapter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printImage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;风景.jpg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出：OldPrinter 打印文本：图片内容：风景.jpg</span></span></code></pre></div><h4 id="装饰器模式" tabindex="-1">装饰器模式 <a class="header-anchor" href="#装饰器模式" aria-label="Permalink to &quot;装饰器模式&quot;">​</a></h4><p>js中还是试验性功能，ts中可以使用</p><p>主要用在类和方法上，相较于继承是静态的，装饰器可以动态添加，会在类或者方法定义完后再运行装饰器</p><h3 id="行为型设计模式" tabindex="-1">行为型设计模式 <a class="header-anchor" href="#行为型设计模式" aria-label="Permalink to &quot;行为型设计模式&quot;">​</a></h3><h4 id="观察者模式" tabindex="-1">观察者模式 <a class="header-anchor" href="#观察者模式" aria-label="Permalink to &quot;观察者模式&quot;">​</a></h4><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新</p><p>被观察者内部维护了一个观察者数组，当自身发生变化时，会触发观察者的更新函数</p><p>vue3中的响应式就是利用了观察者模式，定义时收集依赖，修改状态时，会触发依赖的更新。</p><h4 id="发布订阅模式" tabindex="-1">发布订阅模式 <a class="header-anchor" href="#发布订阅模式" aria-label="Permalink to &quot;发布订阅模式&quot;">​</a></h4><p>发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责。</p><p>类似vue中的事件总线机制，通过on将事件和回调挂载到总线上，通过emit触发事件来执行所有的相关回调。</p>`,66)]))}const c=i(h,[["render",p]]);export{g as __pageData,c as default};

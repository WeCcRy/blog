# 工程化

## 浏览器是如何渲染页面的

1. 浏览器从后端获取到html文件
2. 浏览器将html文本拆成token，流程如下，逐字符读取(scanner)：
   1. 读到 <：判断 “开始标签的起始”，继续读后面的字符；
   2. 读到 p：判断是标签名（`<p>`），生成一个 “开始标签 Token”，类型标记为StartTag:p；
   3. 读到空格：判断 “标签名结束，接下来是属性”，继续读；
   4. 读到 c-l-a-s-s：识别为属性名 “class”，再读到 = 和 "text"，生成一个 “属性 Token”，关联到前面的StartTag:p；
   5. 读到 >：判断 “开始标签结束”，完成StartTag:p的生成；
   6. 读到 H-e-l-l-o W-o-r-l-d：没有 < 开头，判断是文本内容，生成 “文本 Token”，内容为 “Hello World”；
   7. 读到 <：再次进入标签识别，继续读 /p>，生成 “结束标签 Token”，类型标记为EndTag:p。
   8. 最终这一段文本会拆成 3 个核心 Token：[StartTag:p(属性:class="text"), Text:Hello World, EndTag:p]
3. 通过token生成dom节点：一边读取token，一边通过栈来存储，因为标签都需要闭合，所以可以形成一个个dom节点
4. 通过嵌套关系构成dom树
5. 当html解析中遇到`<link>`链接的时候，会请求链接对应的css文件，如果是行内的`<style>`则直接解析，后面定义的css，如果前者更高的优先级就会被后者覆盖
6. 通过DOM和CSSOM构建RenderTree，因为css的条数众多，因此在匹配css和对应节点的时候，使用的是从右到左的匹配方式，可以筛选掉大量的不匹配节点
7. 下一步进行布局计算（回流/重排 reflow），需要根据节点的样式信息和层级关系，计算元素在屏幕上的位置、宽高、间距等
   1. 一般以html根元素的大小为基准，根元素的大小受视口大小影响，定义的root样式作用在html根元素上，body包含了所有的可见元素
   2. 基于盒子模型确定元素的大小
   3. 根据布局模式确定元素的排列（正常流，浮动，定位，flex，grid）
   4. 递归计算，从根节点开始，先计算父元素的布局信息，再将必要的约束传递给子元素，子元素基于这些约束计算自己的布局，同时可能将结果反馈给父元素，形成 “父→子→父” 的递归循环。
8. 下一步进行重绘，即填充像素，浏览器会分成多个绘制层计算
9. 将多个绘制层合并成多个合并层
10. 引入script
    1.  引入script时候，会打断原来DOM的解析过程
        1.  引入async script。导致的结果就是异步下载script，拿到script后再执行，实质还是会阻塞html的解析，只不过大多数情况下，在获取到script之后，dom已经加载完毕了
        2.  只有外部脚本才可以使用async
        3.  defer script就是异步加载，但是等到dom加载完毕后再执行script
    2.  默认script写在不同地方的影响
        1.  如果写在header中，会请求并加载script，导致无法获取script中的dom对象，可能部分功能失效
        2.  如果写在body的顶部，其结果与header中一致
        3.  如果写在body中部，则可以获取到script标签上方的dom元素
        4.  如果写在body底部和body后，则可以获取到全量的dom元素

补充：
1. css编写方式的影响：使用style编写的时候，会自动执行解析，而使用link的时候，会先请求，待请求完毕后再解析

## 白屏

可能是资源过大，当资源未完全加载完成的时候，浏览器不会渲染DOM

可能是浏览器引入的script脚本中，存在死循环导致阻塞

## 当我点击页面上一个button两次发生了什么

所有的 addEventListener 触发的回调，均会按序添加到一个临时的事件处理队列，默认的addEventListener 监听的是冒泡阶段。等到一个`捕获->目标->冒泡`流程完成后，将临时队列中的内容添加到宏任务队列中等待事件循环机制执行

### 事件捕获

浏览器从 最顶层的文档根节点（document） 开始，向下遍历 DOM 树，直到找到被点击的 button 元素。

如果经过的节点在addEventLister中配置了 {capture:true} ，则会把 click 对应的回调函数添加到临时任务队列

### 事件目标

将 button 的点击事件添加到临时任务队列

### 事件冒泡

事件从目标元素 button 开始，向上回溯 DOM 树，回到文档根节点。同时将经过元素的 click 回调事件加入临时任务队列

以上是单次点击的流程，如果点击两次则会触发两次，同时浏览器会监听两次单击的时间间隔，如果间隔少于一定时间，则会触发dbclick事件。dbclick 事件同样会走`捕获->目标->冒泡`的流程

最后将临时任务队列中的回调添加到全局的宏任务队列等待事件循环机制执行

PS：原生的dbclick一定先触发两次click事件，如果需要取消click事件，需要在click 回调中监听两次操作的间隔。

Finally:[第一次点击的捕获回调 → 第一次点击的目标回调 → 第一次点击的冒泡回调 → 第二次点击的捕获回调 → 第二次点击的目标回调 → 第二次点击的冒泡回调 → dblclick的捕获回调 → dblclick的目标回调 → dblclick的冒泡回调]

**addEventListener(type, listener, options)**

* type: 事件名称，大小写敏感

* listener: 回调事件

* options: 可选配置参数

  * capture: boolean。表示事件是在捕获阶段事发还是冒泡阶段触发，默认为false，即冒泡阶段触发

  * once:boolean。为true时，当执行一次完毕后就会销毁监听器

对目标元素的 capture 配置无论是 true 还是 false ，都会在目标阶段执行，但 capture 为 true 的事件会在 capture 为 false 的事件前执行(可以对一个目标元素的一个事件配置两个回调函数，通过 capture 来区分出先后)。对于 capture 配置一样的则是先绑定的先执行。

## git和svn 的区别

| **问题**     | **Git**                                                                     | **SVN**                                                         |
| ------------ | --------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **模型类型** | 分布式（Distributed）                                                       | 集中式（Centralized）                                           |
| **核心差异** | - 每个开发者本地有完整仓库副本 - 数据分散存储，支持离线操作                 | - 所有代码存储在中央服务器 - 必须联网才能提交代码               |
| **分支实现** | - 轻量级分支（创建 / 切换耗时毫秒级） - 基于指针（commit 哈希），不复制文件 | - 重量级分支（基于文件系统复制） - 耗存储、操作慢（尤其大项目） |
| **合并能力** | - 支持三方合并（自动识别共同祖先） - 冲突解决灵活（可视化工具如 VS Code）   | - 依赖路径匹配，跨分支合并易出错 - 复杂场景需手动处理冲突       |

## git常用命令

```js
git init                     // 新建 git 代码库
git add                      // 添加指定文件到暂存区
git rm                       // 删除工作区文件，并且将这次删除放入暂存区
git commit -m [message]      // 提交暂存区到仓库区
git branch                   // 列出所有分支
git checkout -b [branch]     // 新建一个分支，并切换到该分支
git status                   // 显示有变更文件的状态
```

## git pull 和 git fetch 的区别

- git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。
- git pull 会将远程仓库的变化下载下来，并和当前分支合并。

## git rebase 和 git merge 的区别

git merge 和 git rebase 都是用于分支合并，关键**在** **commit 记录的处理上不同**：

- git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。
- git rebase ,当前所在分支为源分支，rebase xx中的xx为目标分支，会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取源分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了**线性的记录**了。

## 设计模式

### 创造模式

#### 单例模式

确保一个类只有一个实例，并提供一个全局访问点来访问该实例。

#### 工厂模式

##### 简单工厂

通过一个工厂生产所有产品

```js
// 产品接口
class Product {
  operation() { return "Base product"; }
}

// 具体产品
class ConcreteProductA extends Product {
  operation() { return "Product A"; }
}

class ConcreteProductB extends Product {
  operation() { return "Product B"; }
}

// 简单工厂
class Factory {
  createProduct(type) {
    if (type === "A") return new ConcreteProductA();
    if (type === "B") return new ConcreteProductB();
    throw new Error("Invalid product type");
  }
}

// 使用工厂
const factory = new Factory();
const productA = factory.createProduct("A");
console.log(productA.operation()); // 输出: "Product A"
```

##### 工厂方法

工厂提供一个接口，子类实现接口

```js
// 工厂基类
abstract class Creator {
  abstract factoryMethod(): Product; // 抽象产品，具体产品由子类实现
  
  someOperation() {
    const product = this.factoryMethod();
    return `Operation with ${product.operation()}`;
  }
}

// 具体工厂
class ConcreteCreatorA extends Creator {
  factoryMethod() { return new ConcreteProductA(); }
}

class ConcreteCreatorB extends Creator {
  factoryMethod() { return new ConcreteProductB(); }
}

// 使用工厂
const creatorA = new ConcreteCreatorA();
console.log(creatorA.someOperation()); // 输出: "Operation with Product A"
```

### 结构型模式

#### 适配器模式

当两个接口不兼容（如旧接口与新系统不匹配），通过一个 “适配器” 中间层，将一个接口转换为另一个接口，使原本无法一起工作的组件可以协同

```js
// 目标接口（新系统需要的接口）
interface ImagePrinter {
  printImage(image: string): void;
}

// 被适配者（旧接口，不兼容新系统）
class OldPrinter {
  printText(text: string): void {
    console.log(`OldPrinter 打印文本：${text}`);
  }
}

// 适配器（组合被适配者，转换接口）
class PrinterAdapter implements ImagePrinter {
  private oldPrinter: OldPrinter; // 持有被适配者实例

  constructor(oldPrinter: OldPrinter) {
    this.oldPrinter = oldPrinter;
  }

  // 将 printImage 转换为旧接口的 printText
  printImage(image: string): void {
    // 模拟图片转文本逻辑（实际可能更复杂）
    const text = "图片内容"+image;
    this.oldPrinter.printText(text);
  }
}

// 使用示例
const oldPrinter = new OldPrinter();
const adapter = new PrinterAdapter(oldPrinter);
adapter.printImage("风景.jpg"); // 输出：OldPrinter 打印文本：图片内容：风景.jpg
```

#### 装饰器模式

js中还是试验性功能，ts中可以使用

主要用在类和方法上，相较于继承是静态的，装饰器可以动态添加，会在类或者方法定义完后再运行装饰器

### 行为型设计模式

#### 观察者模式

观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新

被观察者内部维护了一个观察者数组，当自身发生变化时，会触发观察者的更新函数

vue3中的响应式就是利用了观察者模式，定义时收集依赖，修改状态时，会触发依赖的更新。

#### 发布订阅模式

发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责。

类似vue中的事件总线机制，通过on将事件和回调挂载到总线上，通过emit触发事件来执行所有的相关回调。
